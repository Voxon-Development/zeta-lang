//\! Grammar tests for the pest-based parser.
//\!
//\! Testing library/framework: Rust built-in test framework (cargo test) with standard `assert\!`/`assert_eq\!`.
//\! These tests validate parsing success/failure for key rules from the grammar diff snippet.

use pest::Parser;
use pest::iterators::{Pair, Pairs};

// If the main crate exposes the parser via a module, adjust the path accordingly.
// We assume a parser like `crate::grammar::Rule` and `crate::grammar::MyParser`.
#[derive(pest_derive::Parser)]
#[grammar = "../src/grammar.pest"] // Adjust the path if grammar resides elsewhere
struct G;

type Rule = crate_rule::RuleShim;

// We create a Rule shim by reusing the generated Rule. If the project already exposes Rule, prefer that.
mod crate_rule {
    // The `Rule` enum will be generated by the derive on G above as `rule::Rule`.
    // We import it here for ergonomic references. If the project exposes a public Rule, replace this shim with `pub use crate::grammar::Rule;`
    pub use super::G as _G;
    pub use _G::Rule as RuleShim;
}

fn parse_ok(rule: Rule, input: &str) -> Pair<Rule> {
    G::parse(rule, input).expect("parse_ok: expected success").into_iter().next().unwrap()
}

fn parse_fail(rule: Rule, input: &str) {
    match G::parse(rule, input) {
        Ok(pairs) => {
            let first = pairs.into_iter().next();
            panic\!("parse_fail: expected failure but got {:?}", first.map(|p| (p.as_rule(), p.as_str())));
        }
        Err(_e) => {}
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use super::Rule;

    // Utility: strip spaces to test WHITESPACE consumption where appropriate
    fn no_ws(s: &str) -> String {
        s.chars().filter(|c| \!c.is_whitespace()).collect()
    }

    #[test]
    fn test_whitespace_and_comments() {
        // WHITESPACE: spaces, tabs, CR, LF
        parse_ok(Rule::WHITESPACE, " ");
        parse_ok(Rule::WHITESPACE, "\t");
        parse_ok(Rule::WHITESPACE, "\r");
        parse_ok(Rule::WHITESPACE, "\n");

        // COMMENT: '//' until newline
        let p = G::parse(Rule::COMMENT, "// foo bar\n").unwrap();
        assert\!(p.as_str().starts_with("//"));

        // COMMENT without trailing newline should not include EOI according to rule (greedy ANY until \n)
        parse_fail(Rule::COMMENT, "// unterminated");
    }

    #[test]
    fn test_ident_and_keywords() {
        // ident: not a keyword; starts with alpha or '_' then alnum or '_'
        parse_ok(Rule::ident, "foo");
        parse_ok(Rule::ident, "_bar_1");
        parse_fail(Rule::ident, "1abc"); // cannot start with digit

        // keywords rejected as ident
        for kw in ["true","false","if","else","while","return","let","for","enum","type"] {
            parse_fail(Rule::ident, kw);
        }
    }

    #[test]
    fn test_numbers_and_strings() {
        parse_ok(Rule::number, "0");
        parse_ok(Rule::number, "12345");
        parse_ok(Rule::number, "-42");

        parse_ok(Rule::string, r#""hello""#);
        parse_ok(Rule::string, r#""he\"llo""#);
        parse_ok(Rule::string, r#""back\\slash""#);
        parse_fail(Rule::string, r#""unterminated"#);
    }

    #[test]
    fn test_program_empty_and_simple_stmt() {
        // Empty program should pass: SOI stmt* EOI
        G::parse(Rule::program, "").unwrap();

        // Simple let statement terminated by semicolon
        let src = "let i32 x = 1;";
        G::parse(Rule::program, src).unwrap();

        // Newline terminator also allowed
        let src_nl = "let i32 x = 1\nreturn x\n";
        G::parse(Rule::program, src_nl).unwrap();
    }

    #[test]
    fn test_let_and_const_and_shorthand() {
        // let: mut? var_type atom '=' expr
        G::parse(Rule::let_stmt, "let i32 x = 10").unwrap();
        G::parse(Rule::let_stmt, "mut i32 x = 10").unwrap_err(); // 'mut' belongs to separate mut_keyword? but var_type first; ensure var_type accepts basic_type etc.

        // const: 'const' var_type ident '=' expr
        G::parse(Rule::const_stmt, "const i64 ANSWER = 42").unwrap();

        // shorthand let: mut? atom ':=' expr
        G::parse(Rule::shorthand_let_stmt, "x := 1").unwrap();
        G::parse(Rule::shorthand_let_stmt, "mut x := 1").unwrap();
    }

    #[test]
    fn test_if_else_block_and_expr_stmt() {
        let src = r#"
            if (x > 0) { return x; } else { return 0; }
        "#;
        G::parse(Rule::if_stmt, src).unwrap();

        // else-if chain
        let src2 = r#"
            if (x > 0) { return x; } else if (x == 0) { return 0; } else { return -x; }
        "#;
        G::parse(Rule::if_stmt, src2).unwrap();
    }

    #[test]
    fn test_match_statement() {
        let src = r#"
            match (x) {
              0 => { return 0; }
              1 => { return 1; }
              _ => { return -1; }
            }
        "#;
        G::parse(Rule::match_stmt, src).unwrap();
    }

    #[test]
    fn test_function_declaration_variants() {
        // Basic function
        let src = r#"
            fun add(a i32, b i32) -> i32 { return a + b; }
        "#;
        G::parse(Rule::fun_decl, src).unwrap_err(); // grammar uses `ident param_list`, not `fun` keyword; ensure invalid

        // According to grammar: (visibility? unsafe? (extern "x")? mut? static? (inline|noinline)? (type_expr ".")? ident generic_params? param_list function_type? (block|arrow|SEMI?))
        let src2 = r#"
            public inline add(a i32, b i32) -> i32 { return a + b; }
        "#;
        G::parse(Rule::fun_decl, src2).unwrap();

        let src3 = r#"extern "c" add() = 1;"#;
        G::parse(Rule::fun_decl, src3).unwrap();
    }

    #[test]
    fn test_struct_and_enum_declarations() {
        G::parse(Rule::struct_decl, "public type Point<T>(x i32, y i32)").unwrap();
        G::parse(Rule::enum_decl, "enum E { A, B, C }").unwrap();
        G::parse(Rule::enum_decl, "public enum R<T> { Some(i32), None }").unwrap();
    }

    #[test]
    fn test_generics_and_qualified_types() {
        G::parse(Rule::generic_params, "<T>").unwrap();
        G::parse(Rule::generic_params, "<const N: Size, T: TraitA, U>").unwrap();

        G::parse(Rule::qualified_type, "ns.Type").unwrap();
        G::parse(Rule::generic_type, "Option<T>").unwrap();
        G::parse(Rule::generic_type, "Result<Ok,Err>").unwrap();
    }

    #[test]
    fn test_operators_and_precedence() {
        // arithmetic
        G::parse(Rule::expr, "1 + 2 * 3").unwrap();
        // comparison
        G::parse(Rule::expr, "a <= b && c \!= d").unwrap();
        // bitwise and shifts
        G::parse(Rule::expr, "(x << 2) | (y & 3)").unwrap();
        // ternary not present; ensure failure:
        parse_fail(Rule::expr, "a ? b : c");
    }

    #[test]
    fn test_array_and_class_init_and_calls() {
        G::parse(Rule::array_literal, "[1, 2, 3]").unwrap();
        G::parse(Rule::class_initialization, "Point { x, y }").unwrap();

        // method calls and optional chaining
        G::parse(Rule::primary, "obj.method(arg1, arg2)").unwrap();
        G::parse(Rule::primary, "obj?.method().field").unwrap();
    }

    #[test]
    fn test_assignment_and_compound_ops() {
        G::parse(Rule::assignment, "x = 1").unwrap();
        G::parse(Rule::assign_expr, "x += 2").unwrap();
        G::parse(Rule::assign_expr, "x <<= 1").unwrap();
        parse_fail(Rule::assign_expr, "1 = x");
    }

    #[test]
    fn test_lambda_and_types() {
        G::parse(Rule::lambda_type, "(i32, i32) -> i32").unwrap();
        G::parse(Rule::lambda_expr, "(a i32, b i32) -> a + b").unwrap();
        G::parse(Rule::var_type, "i32\!").unwrap(); // error prefix
        G::parse(Rule::var_type, "i32?").unwrap(); // nullable suffix
    }

    #[test]
    fn test_visibility_and_modifiers() {
        G::parse(Rule::visibility_modifier, "public").unwrap();
        G::parse(Rule::extern_modifier, "extern").unwrap();
        G::parse(Rule::static_modifier, "static").unwrap();
        G::parse(Rule::unsafe_modifier, "unsafe").unwrap();
    }

    #[test]
    fn test_package_and_import_and_defer() {
        G::parse(Rule::package_stmt, "package a.b.c").unwrap();
        G::parse(Rule::import_stmt, r#"using "std/io""#).unwrap();
        G::parse(Rule::defer_stmt, "defer { return 1; }").unwrap();
        G::parse(Rule::defer_stmt, "defer return 1").unwrap();
    }

    #[test]
    fn test_block_and_program_complex() {
        let src = r#"
            package my.pkg
            using "std/io";
            public type Point(x i32, y i32)
            extern "c" print(msg str) -> i32;
            if (true) {
                let i32 x = 1;
                match (x) {
                    0 => { return 0; }
                    _ => { return 1; }
                }
            } else {
                defer { return; }
            }
        "#;
        G::parse(Rule::program, src).unwrap();
    }
}