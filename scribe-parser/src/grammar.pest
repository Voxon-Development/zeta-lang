WHITESPACE   = _{ " " | "\t" | "\r" | "\n" }
COMMENT      = _{ "//" ~ (!"\n" ~ ANY)* }

program      =  { SOI ~ stmt* ~ EOI }

stmt = _{ block_stmt | simple_stmt }

statem_decl = { "statem" ~ ident ~ "{" ~ transition* ~ "}" }

interface_decl = { visibility_modifier? ~ "interface" ~ ident ~ "(" ~ param_list ~ ")" }

transition = { state_ref ~ "=>" ~ state_ref ~ ";" }

type_expr = { qualified_type }

qualified_type = { generic_type ~ ("." ~ ident)* }

generic_type = {
    ident ~ generic_params?
  | ident ~ "<" ~ generic_placeholder ~ ("," ~ generic_placeholder)* ~ ">"
}

generic_placeholder = { ident ~ (":" ~ ident)? }

state_ref = { ident | "*" }

block_stmt = _{ if_stmt | while_stmt | for_stmt | match_stmt | fun_decl | struct_decl | enum_decl | unsafe_block | block }

simple_stmt = _{ (import_stmt | let_stmt | const_stmt | return_stmt | expr_stmt | break_stmt | continue_stmt | defer_stmt) ~ stmt_terminator? }

defer_stmt = { "defer" ~ (block | stmt) }

const_keyword = { "const" }
generic_param = { const_keyword? ~ ident ~ (":" ~ ident ~ ("," ~ ident)*)? }
generic_params = { "<" ~ generic_param ~ ("," ~ generic_param)* ~ ">" }

impl_decl = {
    "impl" ~ generic_params? ~ type_expr ~ "for" ~ type_expr ~ ("{" ~ fun_decl* ~ "}")
}

stmt_terminator = _{ SEMI | WHITESPACE* ~ "\n"+ ~ WHITESPACE* }
SEMI = _{ ";" }

break_stmt     = { "break" }
continue_stmt  = { "continue" }

inline_keyword = { "inline" }
noinline_keyword = { "noinline" }
sealed_keyword = { "sealed" }

import_stmt = { "using" ~ string }
package_stmt = { "package" ~ (ident ~ ("." ~ ident)*) }
let_stmt = { mut_keyword? ~ var_type ~ atom ~ "=" ~ expr }
shorthand_let_stmt = { mut_keyword? ~ atom ~ ":=" ~ expr }
const_stmt = { "const" ~ var_type ~ ident ~ "=" ~ expr }
return_stmt = { "return" ~ expr? }
if_stmt = { "if" ~ "(" ~ expr ~ ")" ~ block ~ (("else" ~ (block | if_stmt))?) }
while_stmt = { "while" ~ "(" ~ expr ~ ")" ~ block }
for_stmt = { "for" ~ "(" ~ atom ~ ":=" ~ expr ~ ")" ~ block }

stmt_ending    = _{ "\n" | WHITESPACE* }

match_stmt     = { "match" ~ "(" ~ expr ~ ")" ~ "{" ~ match_arm* ~ "}" }
unsafe_block   = { "unsafe" ~ block }
expr_stmt      = { expr }

unsafe_keyword = { "unsafe" }

extern_block = { extern_modifier ~ string ~ "{" ~ fun_decl* ~ "}" }

function_type_annotation = { "->" ~ var_type }

struct_decl = { visibility_modifier? ~ "type" ~ ident ~ generic_params? ~ param_list? }

fun_decl = {
    visibility_modifier? ~ unsafe_modifier? ~ (extern_modifier ~ string)? ~
    mut_keyword? ~ static_modifier? ~ (inline_keyword | noinline_keyword)? ~
    (type_expr ~ ".")? ~ ident ~ generic_params? ~ param_list ~ function_type_annotation? ~ (block | arrow_expr | SEMI?)
}

own_keyword = { "own" }

param = { visibility_modifier? ~ mut_keyword? ~ own_keyword? ~ var_type ~ ident ~ ("=" ~ expr)? }
param_list = { "(" ~ (param ~ ("," ~ param)*)? ~ ")" }

arrow_expr = { "=" ~ expr ~ SEMI? }

visibility_modifier = { "public" | "private" | "package" | "module" }
unsafe_modifier     = { "unsafe" }
extern_modifier = { "extern" }
static_modifier     = { "static" }

type_decl = { "type" ~ ident ~ "=" ~ ident }

enum_decl = { visibility_modifier? ~ "enum" ~ ident ~ generic_params? ~ "{" ~ enum_variant* ~ "}" }
enum_variant = { ident ~ ("(" ~ enum_variant_field_list ~ ")")? }
enum_variant_field_list = { type_expr ~ ("," ~ type_expr)* }

block = { "{" ~ stmt* ~ expr? ~ "}" }
match_arm = { pattern ~ "=>" ~ block }

pattern = _{ ident | number | string | tuple_pattern | wildcard_pattern }
class_initialization = { ident ~ "{" ~ (expr_list)? ~ "}" }

expr_list = { expr ~ ("," ~ expr)* }
tuple_pattern = { "(" ~ (pattern ~ ("," ~ pattern)*)? ~ ")" }
wildcard_pattern = { "_" }

visibility = _{ public_keyword | private_keyword | protected_keyword }
public_keyword = { "public" }
private_keyword = { "private" }
protected_keyword = { "protected" }

mut_keyword = { "mut" }
keyword = _{ "true" | "false" | "if" | "else" | "while" | "return" | "let" | "for" | "enum" | "type" }

ident = @{ !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
number = @{ "-"? ~ ASCII_DIGIT+ }
string = @{ "\"" ~ string_inner* ~ "\"" }
string_inner = _{ "\\\"" | "\\\\" | (!"\"" ~ ANY) }

expr = { class_initialization | assignment }
assignment = { lhs ~ assign_op ~ expr | logic_or }
lhs = { primary }

boolean = { "true" | "false" }

logic_or  = { logic_and ~ ("||" ~ logic_and)* }
logic_and = { bit_or ~ ("&&" ~ bit_or)* }
bit_or    = { bit_xor ~ ("|" ~ bit_xor)* }
bit_xor   = { bit_and ~ ("^" ~ bit_and)* }
bit_and   = { equality ~ ("&" ~ equality)* }
equality  = { comparison ~ (("==" | "!=") ~ comparison)* }
comparison = { shift ~ (comparison_operators ~ shift)* }
shift     = { term ~ (("<<" | ">>") ~ term)* }

comparison_operators = { "<" | ">" | "<=" | ">=" | "!=" | "==" }
term = { factor ~ (operator_add_sub ~ factor)* }
factor = { unary ~ (operator_mul_div ~ unary)* }
unary = { ("!" | "-" | "+")* ~ primary }

primary = { atom ~ ( ( ("." | "?.") ~ atom ) | call_args)* }
array_literal = { "[" ~ (expr ~ ("," ~ expr)*)? ~ "]" }
atom = _{ parenthesized_expr | pattern | class_initialization | boolean | array_literal }

call_args = { "(" ~ (expr ~ ("," ~ expr)*)? ~ ")" }

compound_assign_op = {
    "+=" | "-=" | "*=" | "/=" | "%=" |
    ">>=" | "<<=" | "&=" | "|=" | "^="
}

assign_expr = { ident ~ (assign_op | compound_assign_op) ~ expr }

lambda_type = { param_type_list ~ function_type_annotation }
lambda_expr = { param_list ~ "->" ~ (expr | block) }

param_type_list = { "(" ~ (param_type ~ ("," ~ param_type)*)? ~ ")" }
param_type = { var_type }

var_type = { (lambda_type | basic_type) ~ error_prefix? ~ nullable_suffix? }

error_prefix = { "!" }
nullable_suffix = { "?" }

array_suffix = { "[" ~ atom ~ "]" }
basic_type = { ident | "i32" | "u32" | "f64" | "uf64" | "i64" | "u64" | "i128" | "u128" | "u8" | "i8" | "i16" | "u16" | "boolean" | "str" }

parenthesized_expr = { "(" ~ expr ~ ")" }
operator_add_sub = { "+" | "-" }
operator_mul_div = { "*" | "/" | "%" }
operator_pow = { "^" }
operator_bit_or = { "|" }
operator_bit_and = { "&" }
operator_shift = { ">>" | "<<" | ">>>" | "<<<" }
assign_op = { "=" | compound_assign_op }

comparison_op = { "==" | "!=" | "<=" | ">=" | "<" | ">" }
comparison_expr = { expr ~ comparison_op ~ expr }