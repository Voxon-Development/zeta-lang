WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT    = _{ "//" ~ (!"\n" ~ ANY)* }

program = { SOI ~ stmt* ~ EOI }

stmt = _{ block_stmt | simple_stmt }

statem_decl = { "statem" ~ ident ~ "{" ~ transition* ~ "}" }

interface_decl = { visibility_modifier? ~ sealed_keyword? ~ "interface" ~ ident ~ permits_expr? ~ "(" ~ param_list ~ ")" }
permits_expr = { "permits" ~ type_expr ~ ("," ~ type_expr)* }

transition = { state_ref ~ "=>" ~ state_ref ~ (block | stmt_terminator)? }

type_expr = { qualified_type }

qualified_type = { generic_type ~ ("." ~ ident)* }

generic_type = {
    ident ~ generic_params?
}

generic_placeholder = { ident ~ (":" ~ ident)? }

state_ref = { ident | "*" }

block_stmt = _{ if_stmt | while_stmt | for_stmt | match_stmt | fun_decl | destructor_decl | struct_decl | enum_decl | effect_decl | unsafe_block | block }

simple_stmt = _{ (import_stmt | let_stmt | shorthand_let_stmt | const_stmt | return_stmt | expr_stmt | break_stmt | continue_stmt | defer_stmt) ~ stmt_terminator? }

defer_stmt = { "defer" ~ (block | stmt) }

const_keyword  = { "const" }
generic_param  = { const_keyword? ~ ident ~ (":" ~ var_type ~ ("," ~ var_type)*)? }
generic_params = { "<" ~ generic_param ~ ("," ~ generic_param)* ~ ">" }

impl_decl = {
    "impl" ~ generic_params? ~ type_expr ~ ("for" ~ type_expr)? ~ block
}

stmt_terminator = _{ SEMI | WHITESPACE* ~ "\n"+ ~ WHITESPACE* }
SEMI            = _{ ";" }

break_stmt    = { "break" }
continue_stmt = { "continue" }

inline_keyword   = { "inline" }
noinline_keyword = { "noinline" }
sealed_keyword   = { "sealed" }

import_stmt        = { "import" ~ string ~ stmt_terminator? }
package_stmt       = { "package" ~ (ident ~ ("." ~ ident)*) ~ stmt_terminator? }
let_stmt           = { "let" ~ mut_keyword? ~ (var_type ~ ident ~ "=" | ident ~ ":=") ~ expr ~ stmt_terminator? }
shorthand_let_stmt = { mut_keyword? ~ ident ~ ":=" ~ expr ~ stmt_terminator? }
const_stmt         = { "const" ~ var_type ~ ident ~ "=" ~ expr ~ stmt_terminator? }
return_stmt        = { "return" ~ expr? ~ stmt_terminator? }
if_stmt            = { "if" ~ expr ~ block ~ (("else" ~ (block | if_stmt))?) ~ stmt_terminator? }
while_stmt         = { "while" ~ expr ~ block ~ stmt_terminator? }
for_stmt           = { "for" ~ atom ~ ":=" ~ expr ~ block ~ stmt_terminator? }

stmt_ending = _{ "\n" | WHITESPACE* }

destructor_decl = {
    visibility_modifier? ~ "~" ~ ident ~ "(" ~ ")" ~ block ~ stmt_terminator?
}

effect_decl = {
    visibility_modifier? ~ sealed_keyword? ~ "effect" ~ ident ~ permits_expr? ~ "(" ~ param_list ~ ")" ~ block
}

effect_annotation = { "\\" ~ type_expr }


match_stmt   = { "match" ~ expr ~ "{" ~ match_arm* ~ "}" ~ stmt_terminator? }
unsafe_block = { "unsafe" ~ block ~ stmt_terminator? }
expr_stmt    = { expr ~ stmt_terminator? }

unsafe_keyword = { "unsafe" }

extern_block = { extern_modifier ~ string ~ "{" ~ fun_decl* ~ "}" ~ stmt_terminator? }

function_type_annotation = { "->" ~ var_type }

struct_decl = { visibility_modifier? ~ "struct" ~ ident ~ generic_params? ~ field_args ~ block }

fun_decl = {
    visibility_modifier? ~ unsafe_modifier? ~
    (extern_modifier ~ string)? ~
    (comptime_keyword | inline_keyword | noinline_keyword)? ~ // can't inline a comptime/noinline function and vice versa
    var_type ~ ident ~
    generic_params? ~ param_list ~ effect_annotation* ~ (block | arrow_expr)? ~ stmt_terminator?
}

own_keyword = { "own" }

param = { typed_param | this_param }

typed_param = { visibility_modifier? ~ mut_keyword? ~ own_keyword? ~ var_type ~ ident ~ ("=" ~ expr)? }
this_param  = { mut_keyword? ~ own_keyword? ~ this_type }
param_list = { "(" ~ (param ~ ("," ~ param)*)? ~ ")" }

arrow_expr = { "=" ~ expr }

visibility_modifier = { "public" | "private" | "package" | "module" }
unsafe_modifier     = { "unsafe" }
extern_modifier     = { "extern" }
static_modifier     = { "static" }

type_decl = { "struct" ~ ident ~ "=" ~ ident }

enum_decl               = { visibility_modifier? ~ "enum" ~ ident ~ generic_params? ~ "{" ~ enum_variant* ~ "}"  ~ stmt_terminator? }
enum_variant            = { ident ~ ("(" ~ enum_variant_field_list ~ ")")? }
enum_variant_field_list = { type_expr ~ ("," ~ type_expr)* }

block     = { "{" ~ stmt* ~ expr? ~ "}" }
match_arm = { pattern ~ "=>" ~ block }

pattern              = _{ ident | number | string | tuple_pattern | wildcard_pattern }

field_args            = { "{" ~ param ~ ("," ~ param)* ~ "}" }
field_args_init       = _{ "{" ~ (field_init ~ ("," ~ field_init)*) ~ "}" }
field_init            = { ident ~ "=" ~ expr }
ctor_positional_list  = { param ~ ("," ~ param)* }
ctor_args             = _{ "(" ~ (ctor_positional_list)? ~ ")" }
ctor_args_init         = _{ "(" ~ (expr ~ ("," ~ expr)*) ~ ")" }

class_initialization  = {
      ident ~ (field_args | ctor_args_init)
}

expr_list        = { expr ~ ("," ~ expr)* }
tuple_pattern    = { "(" ~ (pattern ~ ("," ~ pattern)*)? ~ ")" }
wildcard_pattern = { "_" }

visibility      = _{ public_keyword | private_keyword | module_keyword | package_keyword }
public_keyword  =  { "public" }
private_keyword =  { "private" }
module_keyword  =  { "module" }
package_keyword =  { "package" }

comptime_keyword = { "comptime" }

mut_keyword =  { "mut" }
keyword     = _{ "true" | "false" | "if" | "else" | "while" | "return" | "for" | "enum" | "type" | "let" | "const" | "mut" | "struct" | "interface" | "impl" | "match" | "break" | "continue" | "unsafe" | "extern" | "inline" | "noinline" | "comptime" | "defer" | "import" | "package" | "this" }

ident        = @{ !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
number       = @{ "-"? ~ ASCII_DIGIT+ }
decimal      = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
char         = @{ "'" ~ ("\\" ~ ANY | (!"'" ~ ANY)) ~ "'" }
string       = @{ "\"" ~ string_inner* ~ "\"" }
string_inner = _{ "\\\"" | "\\\\" | (!"\"" ~ ANY) }

expr = { assignment }

assign_op = { ":=" | "=" }
compound_assign_op = {
    "+="
  | "-="
  | "*="
  | "/="
  | "%="
  | ">>="
  | "<<="
  | ">>>="
  | "<<<="
  | "&="
  | "|="
  | "^="
}

assignment = {
    lhs ~ (assign_op | compound_assign_op) ~ assignment
  | logic_or
}

lhs = { (ident | this_type) ~ (("." ~ ident) | array_suffix)* }

boolean = { "true" | "false" }

logic_or   = { logic_and ~ ("||" ~ logic_and)* }
logic_and  = { bit_or ~ ("&&" ~ bit_or)* }

bit_or     = { bit_xor ~ ("|" ~ bit_xor)* }
bit_xor    = { bit_and ~ ("^" ~ bit_and)* }
bit_and    = { equality ~ ("&" ~ equality)* }

equality   = { comparison ~ (("==" | "!=" | "~=") ~ comparison)* }
comparison = { shift ~ (comparison_operators ~ shift)* }

operator_shift = { ">>>" | "<<<" | ">>" | "<<" }
shift      = { term ~ ((operator_shift) ~ term)* }

term                 = { factor ~ (operator_add_sub ~ factor)* }
factor               = { unary ~ (operator_mul_div ~ unary)* }
unary                = { ("~" | "-" | "+")* ~ primary }

operator_add_sub = { "+" | "-" }
operator_mul_div = { "*" | "/" | "%" }

comparison_operators = { "<=" | ">=" | "<" | ">" | "~=" | "!=" | "==" }

primary = {
      atom ~ postfix
    | "(" ~ expr ~ ")" ~ postfix
    | if_stmt ~ postfix
    | match_stmt ~ postfix
}

postfix = _{ (("." ~ ident) | ("?." ~ ident) | call_args | array_suffix)* }

array_literal =  { "[" ~ (expr ~ ("," ~ expr)*)? ~ "]" }

atom = _{ parenthesized_expr
        | class_initialization
        | boolean
        | array_literal
        | lambda_expr
        | ident
        | decimal
        | number
        | char
        | string
        | this_type }

call_args = { "(" ~ (expr ~ ("," ~ expr)*)? ~ ")" }

assign_expr = { ident ~ (assign_op | compound_assign_op) ~ expr }

lambda_type = { param_type_list ~ function_type_annotation }
lambda_expr = { param_list ~ "->" ~ (expr | block) }

param_type_list = { "(" ~ (param_type ~ ("," ~ param_type)*)? ~ ")" }
param_type      = { var_type }

var_type  = { (lambda_type | basic_type) ~ nullable_suffix? }
this_type = { "this" }
type_list = { var_type ~ ("," ~ var_type)* }

nullable_suffix = { "?" }

array_suffix = { "[" ~ expr ~ "]" }
basic_type   = { (ident ~ ("<" ~ type_list ~ ">")?) | "i32" | "u32" | "f32" | "f64" | "uf32" | "uf64" | "i64" | "u64" | "i128" | "u128" | "u8" | "i8" | "i16" | "u16" | "boolean" | "char" | "str" }

parenthesized_expr = { "(" ~ expr ~ ")" }
operator_pow       = { "^" }
operator_bit_or    = { "|" }
operator_bit_and   = { "&" }
operator_shift_raw = { ">>" | "<<" | ">>>" | "<<<" }

comparison_op   = { "==" | "~=" | "<=" | ">=" | "<" | ">" }
comparison_expr = { expr ~ comparison_op ~ expr }
