package zeta.lang

enum Result<T, E> {
    Ok(T value),
    Err(E error),
}

impl<T, E> Result<T, E> {
    inline bool isOk(this) {
        match this {
            Ok(_) => true,
            Err(_) => false,
        }
    }

    inline bool isErr(this) {
        match this {
            Ok(_) => false,
            Err(_) => true,
        }
    }

    inline T? ok(this) {
        match this {
            Ok(v) => v,
            Err(_) => null,
        }
    }

    inline E? err(this) {
        match this {
            Ok(_) => null,
            Err(e) => e,
        }
    }

    inline T get(this) {
        match this {
            Ok(v) => v,
            Err(_) => panic("called `Result.get()` on an Err value"),
        }
    }

    inline T expect(this, StringView msg) {
        match this {
            Ok(v) => v,
            Err(_) => panic(msg),
        }
    }

    inline unsafe T getUnchecked(this) {
        match this {
            Ok(v) => v,
            Err(_) => unreachable_unchecked(),
        }
    }

    inline void ifOk(this, void f(T)) {
        match this {
            Ok(v) => f(v),
            Err(_) => {},
        }
    }

    inline void ifErr(this, void f(E)) {
        match this {
            Ok(_) => {},
            Err(e) => f(e),
        }
    }


    inline Result<U, E> map<U>(this, U f(T)) {
        match this {
            Ok(v) => Ok(f(v)),
            Err(e) => Err(e),
        }
    }

    inline Result<T, F> mapErr<F>(this, F f(E)) {
        match this {
            Ok(v) => Ok(v),
            Err(e) => Err(f(e)),
        }
    }

    inline Result<U, E> andThen<U>(this, Result<U, E> f(T)) {
        match this {
            Ok(v) => f(v),
            Err(e) => Err(e),
        }
    }

    inline Result<T, F> orElse<F>(this, Result<T, F> f(E)) {
        match this {
            Ok(v) => Ok(v),
            Err(e) => f(e),
        }
    }

    // Return contained value or a fallback if Err
    inline T unwrapOr(this, T fallback) {
        match this {
            Ok(v) => v,
            Err(_) => fallback,
        }
    }

    // Return contained value or compute fallback lazily
    inline T unwrapOrElse(this, T f(E)) {
        match this {
            Ok(v) => v,
            Err(e) => f(e),
        }
    }
}