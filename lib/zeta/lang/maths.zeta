package zeta.lang

// Constants
const f64 PI = 3.14159265358979323846264338327950288419716939937510

// Min/max for integer types
const u8 U8_MAX = 255
const u8 U8_MIN = 0
const i8 I8_MAX = 127
const i8 I8_MIN = -128

const u16 U16_MAX = 65535
const u16 U16_MIN = 0
const i16 I16_MAX = 32767
const i16 I16_MIN = -32768

const u32 U32_MAX = 4294967295
const u32 U32_MIN = 0
const i32 I32_MAX = 2147483647
const i32 I32_MIN = -2147483648

const u64 U64_MAX = 18446744073709551615
const u64 U64_MIN = 0
const i64 I64_MAX = 9223372036854775807
const i64 I64_MIN = -9223372036854775808

const u128 U128_MAX = 340282366920938463463374607431768211455
const u128 U128_MIN = 0
const i128 I128_MAX = 170141183460469231731687303715884105727
const i128 I128_MIN = -170141183460469231731687303715884105728

// Float min/max
const f32 F32_MAX = 3.4028235e38
const f32 F32_MIN = -3.4028235e38
const f64 F64_MAX = 1.7976931348623157e308
const f64 F64_MIN = -1.7976931348623157e308

const f64 F64_NAN = 0.0 / 0.0

// Functions
inline f64 floor(f64 x) {
    xi := x as i64
    if (x < xi as f64) { return (xi - 1) as f64 } else { xi as f64 }
}

inline f64 ceil(f64 x) {
    xi := x as i64
    if (x > xi as f64) { return (xi + 1) as f64 } else { xi as f64 }
}

inline f64 abs(f64 x) {
    if (x < 0.0) { -x } else { x }
}

// Inlined to `fsqrt` instruction in the CPU by the compiler.
extern "intrinsic" f64 fsqrt(f64 x);

inline f64 pow(f64 x, f64 y) {
    // naive implementation using exp and ln
    exp(y * ln(x))
}

f64 ln(f64 x) {
    // simple iterative approximation for natural log
    if (x <= 0.0) { return F64_NAN }

    mut n := 0
    mut y := x

    while (y > 2.0) {
        y /= 2.718281828459045
        n += 1
    }

    mut result := 0.0
    mut term := (y - 1) / (y + 1)
    mut term2 := term
    for (i := (1..50).stepBy(2)) {
        result += term2 / i as f64
        term2 *= term * term
    }

    2.0 * result + n as f64
}

f64 exp(f64 x) {
    // naive Taylor series
    mut sum := 1.0
    mut term := 1.0
    for (i := 1..50) {
        term *= x / i as f64
        sum += term
    }
    sum
}

f64 sin(f64 x) {
    mut term := x
    mut sum := x
    mut n := 1
    for (_ := 0..10) {
        term *= -x * x / ((2 * n) as f64 * (2 * n + 1) as f64)
        sum += term
        n += 1
    }
    sum
}

f64 cos(f64 x) {
    mut term := 1.0
    mut sum := 1.0
    mut n := 1
    for (_ := 0..10) {
        term *= -x * x / ((2 * n - 1) as f64 * (2 * n) as f64)
        sum += term
        n += 1
    }
    sum
}

inline f64 tan(f64 x) {
    sin(x) / cos(x)
}
