package zeta.lang

// Constants
const PI: f64 = 3.14159265358979323846264338327950288419716939937510

// Min/max for integer types
const U8_MAX: u8 = 255
const U8_MIN: u8 = 0
const I8_MAX: i8 = 127
const I8_MIN: i8 = -128

const U16_MAX: u16 = 65535
const U16_MIN: u16 = 0
const I16_MAX: i16 = 32767
const I16_MIN: i16 = -32768

const U32_MAX: u32 = 4294967295
const U32_MIN: u32 = 0
const I32_MAX: i32 = 2147483647
const I32_MIN: i32 = -2147483648

const U64_MAX: u64 = 18446744073709551615
const U64_MIN: u64 = 0
const I64_MAX: i64 = 9223372036854775807
const I64_MIN: i64 = -9223372036854775808

const U128_MAX: u128 = 340282366920938463463374607431768211455
const U128_MIN: u128 = 0
const I128_MAX: i128 = 170141183460469231731687303715884105727
const I128_MIN: i128 = -170141183460469231731687303715884105728

// Float min/max
const F32_MAX: f32 = 3.4028235e38
const F32_MIN: f32 = -3.4028235e38
const F64_MAX: f64 = 1.7976931348623157e308
const F64_MIN: f64 = -1.7976931348623157e308

const F64_NAN: f64 = 0.0 / 0.0

// Functions
inline floor(f64 x) -> f64 {
    xi := x as i64
    if (x < xi as f64) { return (xi - 1) as f64 } else { xi as f64 }
}

inline ceil(f64 x) -> f64 {
    xi := x as i64
    if (x > xi as f64) { return (xi + 1) as f64 } else { xi as f64 }
}

inline abs(f64 x) -> f64 {
    if (x < 0.0) { -x } else { x }
}

// Inlined to `fsqrt` instruction in the CPU by the compiler.
extern "intrinsic" sqrt(f64 x) -> f64;

inline pow(f64 x, f64 y) -> f64 {
    // naive implementation using exp and ln
    exp(y * ln(x))
}

ln(f64 x) -> f64 {
    // simple iterative approximation for natural log
    if (x <= 0.0) { return F64_NAN }

    mut n := 0
    mut y := x

    while (y > 2.0) {
        y /= 2.718281828459045
        n += 1
    }

    mut result := 0.0
    mut term := (y - 1) / (y + 1)
    mut term2 := term
    for (i := (1..50).stepBy(2)) {
        result += term2 / i as f64
        term2 *= term * term
    }

    2.0 * result + n as f64
}

exp(f64 x) -> f64 {
    // naive Taylor series
    mut sum := 1.0
    mut term := 1.0
    for (i := 1..50) {
        term *= x / i as f64
        sum += term
    }
    sum
}

sin(f64 x) -> f64 {
    mut term := x
    mut sum := x
    mut n := 1
    for (_ := 0..10) {
        term *= -x * x / ((2 * n) as f64 * (2 * n + 1) as f64)
        sum += term
        n += 1
    }
    sum
}

cos(f64 x) -> f64 {
    mut term := 1.0
    mut sum := 1.0
    mut n := 1
    for (_ := 0..10) {
        term *= -x * x / ((2 * n - 1) as f64 * (2 * n) as f64)
        sum += term
        n += 1
    }
    sum
}

inline tan(f64 x) -> f64 {
    sin(x) / cos(x)
}
