package zeta.lang

const PI: f64 = 3.14159265358979323846264338327950288419716939937510

const U8_MAX: u8 = 255
const U8_MIN: u8 = 0
const I8_MAX: i8 = 127
const I8_MIN: i8 = -128

const U16_MAX: u16 = 65535
const U16_MIN: u16 = 0
const I16_MAX: i16 = 32767
const I16_MIN: i16 = -32768

const U32_MAX: u32 = 4294967295
const U32_MIN: u32 = 0
const I32_MAX: i32 = 2147483647
const I32_MIN: i32 = -2147483648

const U64_MAX: u64 = 18446744073709551615
const U64_MIN: u64 = 0
const I64_MAX: i64 = 9223372036854775807
const I64_MIN: i64 = -9223372036854775808

const U128_MAX: u128 = 340282366920938463463374607431768211455
const U128_MIN: u128 = 0
const I128_MAX: i128 = 170141183460469231731687303715884105727
const I128_MIN: i128 = -170141183460469231731687303715884105728

const F32_MAX: f32 = 3.4028235e38
const F32_MIN: f32 = -3.4028235e38
const F64_MAX: f64 = 1.7976931348623157e308
const F64_MIN: f64 = -1.7976931348623157e308

const F64_NAN: f64 = 0.0 / 0.0

inline fn floor(x: f64): f64 {
    xi := x as i64
    if (x < xi as f64) { return (xi - 1) as f64 } else { xi as f64 }
}

inline fn ceil(x: f64): f64 {
    xi := x as i64
    if (x > xi as f64) { return (xi + 1) as f64 } else { xi as f64 }
}

inline fn abs(x: f64): f64 {
    if (x < 0.0) { -x } else { x }
}

extern "intrinsic" fn fsqrt(x: f64): f64;

inline fn pow(x: f64, y: f64): f64 {
    exp(y * ln(x))
}

fn ln(x: f64): f64 {
    if (x <= 0.0) { return F64_NAN }

    mut n := 0
    mut y := x

    while (y > 2.0) {
        y /= 2.718281828459045
        n += 1
    }

    mut result := 0.0
    mut term := (y - 1) / (y + 1)
    mut term2 := term
    for i in (1..50).step_by(2) {
        result += term2 / i as f64
        term2 *= term * term
    }

    2.0 * result + n as f64
}

fn exp(x: f64): f64 {
    mut sum := 1.0
    mut term := 1.0
    for i in 1..50 {
        term *= x / i as f64
        sum += term
    }
    sum
}

fn sin(x: f64): f64 {
    mut term := x
    mut sum := x
    mut n := 1
    for ignored in 0..10 {
        term *= -x * x / ((2 * n) as f64 * (2 * n + 1) as f64)
        sum += term
        n += 1
    }
    sum
}

fn cos(x: f64): f64 {
    mut term := 1.0
    mut sum := 1.0
    mut n := 1
    for ignored in 0..10 {
        term *= -x * x / ((2 * n - 1) as f64 * (2 * n) as f64)
        sum += term
        n += 1
    }
    sum
}

inline fn tan(x: f64): f64 {
    sin(x) / cos(x)
}
