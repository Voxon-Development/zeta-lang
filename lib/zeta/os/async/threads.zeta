package zeta.os.async

const SYS_CLONE = 56
const SYS_FORK = 57
const SYS_VFORK = 58
const SYS_EXECVE = 59
const SYS_SET_TID_ADDRESS = 218
const SYS_GETTID = 186
const SYS_FUTEX = 202
const SYS_SEMGET = 64
const SYS_SEMOP = 65
const SYS_SEMCTL = 66
const SYS_EVENTFD2 = 290
const SYS_TIMERFD_CREATE = 283
const SYS_SIGNALFD4 = 289
const SYS_EPOLL_CREATE1 = 291
const SYS_EPOLL_CTL = 233
const SYS_EPOLL_PWAIT = 281

interface OsThreadSystem {
    // 1. Threads / Processes
    createThread(flags: usize, childStack: usize, ptid: usize, ctid: usize, tls: usize) -> isize;
    fork() -> isize;
    vfork() -> isize;
    execve(path: Ptr<u8>, argv: Ptr<Ptr<u8>>, envp: Ptr<Ptr<u8>>) -> isize;
    setTidAddress(tidptr: Ptr<i32>) -> isize;
    getTid() -> isize;

    // 2. Synchronization primitives
    // futex primitive (raw)
    futex(addr: Ptr<i32>, futexOp: i32, val: i32, timeoutPtr: Ptr<u8>, uaddr2: usize, val3: i32) -> isize;

    // SysV semaphores wrappers
    semget(key: i32, nsems: i32, semflg: i32) -> isize;
    semop(semid: i32, sops: Ptr<u8>, nsops: usize) -> isize;
    semctl(semid: i32, semnum: i32, cmd: i32, arg: usize) -> isize;

    // eventfd/timerfd/signalfd
    eventfd2(initval: u32, flags: i32) -> isize;
    timerfdCreate(clockid: i32, flags: i32) -> isize;
    signalfd4(fd: i32, mask: Ptr<u8>, masksize: usize, flags: i32) -> isize;

    // 3. Event/Wait APIs
    epollCreate1(flags: i32) -> isize;
    epollCtl(epfd: i32, op: i32, fd: i32, eventPtr: Ptr<u8>) -> isize;
    epollPwait(epfd: i32, events: Ptr<u8>, maxevents: i32, timeout: i32, sigmask: Ptr<u8>, sigsetsize: usize) -> isize;

    ioUringSetup(entries: u32, paramsPtr: Ptr<u8>) -> isize;
    ioUringEnter(fd: i32, toSubmit: u32, minComplete: u32, flags: u32, sigPtr: Ptr<u8>, sigsz: usize) -> isize;

    rtSigsuspend(mask: Ptr<u8>, sigsetsize: usize) -> isize;
    rtSigtimedwait(sigset: Ptr<u8>, info: Ptr<u8>, ts: Ptr<u8>, sigsetsize: usize) -> isize;

    // 4. Atomics & low-level primitives (userland intrinsics wrappers)
    atomicLoadI32(addr: Ptr<i32>) -> i32;
    atomicStoreI32(addr: Ptr<i32>, val: i32);
    atomicCompareExchangeI32(addr: Ptr<i32>, old: i32, new: i32) -> boolean;
    atomicFetchAddI32(addr: Ptr<i32>, delta: i32) -> i32;
}