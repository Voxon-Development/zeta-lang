interface Network {
    // Socket lifecycle
    socket(usize domain, usize type, usize protocol) -> isize;         // returns fd or -errno
    socketpair(usize domain, usize type, usize protocol, Ptr<usize> sv) -> isize; // writes two fds into sv[0..1]

    bind(usize sockfd, Ptr<SockAddr> addr, usize addrlen) -> isize;
    listen(usize sockfd, usize backlog) -> isize;
    accept(usize sockfd, Ptr<SockAddr> addr, Ptr<usize> addrlen) -> isize;  // blocking accept -> new fd
    accept4(usize sockfd, Ptr<SockAddr> addr, Ptr<usize> addrlen, usize flags) -> isize; // accept with flags
    connect(usize sockfd, Ptr<SockAddr> addr, usize addrlen) -> isize;
    connect_nonblocking(usize sockfd, Ptr<SockAddr> addr, usize addrlen) -> isize; // convenience

    shutdown(usize sockfd, usize how) -> isize;
    close(usize sockfd) -> isize;

    // Basic I/O
    send(usize sockfd, Ptr<u8> buf, usize len, usize flags) -> isize;
    recv(usize sockfd, Ptr<u8> buf, usize len, usize flags) -> isize;
    sendto(usize sockfd, Ptr<u8> buf, usize len, usize flags, Ptr<SockAddr> dest, usize addrlen) -> isize;
    recvfrom(usize sockfd, Ptr<u8> buf, usize len, usize flags, Ptr<SockAddr> src, Ptr<usize> srclen) -> isize;

    // vectored I/O / message I/O
    sendmsg(usize sockfd, Ptr<MsgHdr> msg, usize flags) -> isize;
    recvmsg(usize sockfd, Ptr<MsgHdr> msg, usize flags) -> isize;
    sendmmsg(usize sockfd, Ptr<MsgHdr> msgs, usize vlen, usize flags) -> isize;
    recvmmsg(usize sockfd, Ptr<MsgHdr> msgs, usize vlen, usize flags, Ptr<TimeSpec> timeout) -> isize;

    // scatter/gather convenience
    readv(usize sockfd, Ptr<IoVec> iov, usize iovcnt) -> isize;
    writev(usize sockfd, Ptr<IoVec> iov, usize iovcnt) -> isize;

    // socket options & attributes
    setsockopt(usize sockfd, usize level, usize optname, Ptr<u8> optval, usize optlen) -> isize;
    getsockopt(usize sockfd, usize level, usize optname, Ptr<u8> optval, Ptr<usize> optlen) -> isize;
    fcntl(usize fd, usize cmd, usize arg) -> isize; // for nonblocking, dup, flags
    ioctl(usize fd, usize request, Ptr<u8> arg) -> isize;

    // Address helpers
    inet_pton(usize af, Ptr<u8> src, Ptr<u8> dst) -> isize;
    inet_ntop(usize af, Ptr<u8> src, Ptr<u8> dst, usize size) -> Ptr<u8>; // returns dst or null
    getaddrinfo(Ptr<u8> node, Ptr<u8> service, Ptr<AddrInfoHints> hints, Ptr<Ptr<AddrInfo>> res) -> isize;
    freeaddrinfo(Ptr<AddrInfo> res) -> isize;
    getnameinfo(Ptr<SockAddr> sa, usize salen, Ptr<u8> host, usize hostlen, Ptr<u8> serv, usize servlen, usize flags) -> isize;

    // Control / polling / event loops
    poll(Ptr<PollFd> fds, usize nfds, isize timeout_ms) -> isize;
    select(usize nfds, Ptr<FdSet> readfds, Ptr<FdSet> writefds, Ptr<FdSet> exceptfds, Ptr<TimeVal> timeout) -> isize;

    // Linux-specific high-performance APIs (wraps epoll/kqueue/io_uring)
    epoll_create(usize flags) -> isize;
    epoll_ctl(usize epfd, usize op, usize fd, Ptr<EpollEvent> event) -> isize;
    epoll_wait(usize epfd, Ptr<EpollEvent> events, usize maxevents, isize timeout) -> isize;

    // Packet-level / raw sockets
    packet_socket(usize protocol, usize ifindex, usize type) -> isize; // PF_PACKET helper
    send_packet(usize sockfd, Ptr<u8> buf, usize len, usize flags, Ptr<SockAddrLL> addr) -> isize;
    recv_packet(usize sockfd, Ptr<u8> buf, usize len, usize flags, Ptr<SockAddrLL> addr, Ptr<usize> addrlen) -> isize;

    // TUN/TAP devices (create/manage tunnel interfaces)
    tun_open(Ptr<u8> devname, usize flags) -> isize;          // returns tun fd
    tun_set_iff(usize fd, Ptr<TunIfReq> req) -> isize;
    tun_read(usize fd, Ptr<u8> buf, usize len) -> isize;
    tun_write(usize fd, Ptr<u8> buf, usize len) -> isize;

    // Netlink (route / rtnetlink helpers)
    netlink_socket(usize protocol) -> isize;
    netlink_send(usize fd, Ptr<u8> buf, usize len, usize flags) -> isize;
    netlink_recv(usize fd, Ptr<u8> buf, usize len, usize flags) -> isize;

    // Routing & interface helpers (wrappers around ioctl/netlink)
    get_if_index(Ptr<u8> ifname) -> isize;                  // returns ifindex or -errno
    set_iface_up(Ptr<u8> ifname, bool up) -> isize;
    set_iface_addr(Ptr<u8> ifname, Ptr<SockAddr> addr) -> isize;
    get_iface_flags(Ptr<u8> ifname, Ptr<usize> flags) -> isize;

    // Multiplexed async primitives
    // These should be non-blocking-friendly and may return -EAGAIN.
    asyncAccept(usize sockfd, Ptr<SockAddr> addr, Ptr<usize> addrlen) -> isize;
    asyncConnect(usize sockfd, Ptr<SockAddr> addr, usize addrlen) -> isize;
    asyncRecv(usize sockfd, Ptr<u8> buf, usize len, usize flags) -> isize;
    asyncSend(usize sockfd, Ptr<u8> buf, usize len, usize flags) -> isize;
    asyncRecvFrom(usize sockfd, Ptr<u8> buf, usize len, usize flags, Ptr<SockAddr> src, Ptr<usize> srclen) -> isize;
    asyncSendTo(usize sockfd, Ptr<u8> buf, usize len, usize flags, Ptr<SockAddr> dest, usize addrlen) -> isize;
    asyncPoll(Ptr<PollFd> fds, usize nfds, isize timeout_ms) -> isize;

    // High-throughput helpers
    sendfile(usize out_fd, usize in_fd, Ptr<isize> offset, usize count) -> isize;
    splice(usize fd_in, Ptr<isize> off_in, usize fd_out, Ptr<isize> off_out, usize len, usize flags) -> isize;

    // Diagnostic helpers
    getpeername(usize sockfd, Ptr<SockAddr> addr, Ptr<usize> addrlen) -> isize;
    getsockname(usize sockfd, Ptr<SockAddr> addr, Ptr<usize> addrlen) -> isize;
    socket_status(usize sockfd, Ptr<SocketStatus> status_out) -> isize; // convenience

    // Utility: convert host/network byte order (endian helpers)
    hton16(usize v) -> usize;
    ntoh16(usize v) -> usize;
    hton32(usize v) -> usize;
    ntoh32(usize v) -> usize;
}